
__all__ = ["transform_tags"]

import logging
import re

from ....constants import TagsOperations
from ....utils.misc import hash_object

logger = logging.getLogger(__name__)

len_default_hash = len(hash_object(b""))

denied_remove_filter = re.compile(
    "^(?:id|state|type)=?"
)


def transform_tags(tags, oldtags=None, operation=TagsOperations.append):
    newtags = {}
    newtags_set = set()
    key_hashes = set()
    tags = tags or []
    oldtags = oldtags or []
    operation = operation or TagsOperations.append
    new_had_keyhash = False
    if operation == TagsOperations.delete and oldtags:
        tags = filter(
            lambda x: not denied_remove_filter.match(x),
            tags
        )
        remove_filter = re.compile(
            r"^(?:%s)" % "|".join(map(
                re.escape,
                tags
            ))
        )
        tags = filter(
            lambda x: not remove_filter.match(x),
            oldtags
        )
    for tag in tags:
        splitted_tag = tag.split("=", 1)
        if splitted_tag[0] == "id":
            logger.warning("id is an invalid tag (autogenerated)")
            continue
        if splitted_tag[0] == "state":
            if newtags.get("state"):
                raise ValueError("state=<foo> is a unique tag")
            elif len(splitted_tag) == 1:
                raise ValueError("state should be tag not flag")
        elif splitted_tag[0] == "type":
            if newtags.get("type"):
                raise ValueError("type=<foo> is a unique tag")
            elif len(splitted_tag) == 1:
                raise ValueError("type should be tag not flag")
        elif splitted_tag[0] == "key_hash":
            if len(splitted_tag) == 1:
                raise ValueError("key_hash should be tag not flag")
            new_had_keyhash = True
            if len_default_hash == len(splitted_tag[1]):
                key_hashes.add(splitted_tag[1])
        if len(tag) > 8000:
            raise ValueError("Tag too big")
        if len(splitted_tag) == 2:
            s = newtags.setdefault(splitted_tag[0], set())
            if not isinstance(s, set):
                raise ValueError("Tag and Flag name collision")
            s.add(splitted_tag[1])
        elif newtags.setdefault(splitted_tag[0], None) is not None:
            raise ValueError("Tag and Flag name collision")
        newtags_set.add(splitted_tag[0])

    if operation != TagsOperations.delete and oldtags:
        for tag in oldtags:
            splitted_tag = tag.split("=", 1)
            if splitted_tag[0] == "id":
                continue
            if splitted_tag[0] == "state":
                if newtags.get("state"):
                    continue
            elif splitted_tag[0] == "type":
                t = newtags.get("type")
                if t and splitted_tag[1] not in t:
                    raise ValueError("Cannot change type")
                elif t:
                    continue
            elif splitted_tag[0] == "key_hash":
                if operation == TagsOperations.replace and new_had_keyhash:
                    continue
                if len_default_hash == len(splitted_tag[1]):
                    key_hashes.add(splitted_tag[1])

            if len(splitted_tag) == 2:
                if (
                    operation == TagsOperations.append or
                    splitted_tag[0] not in newtags_set
                ):
                    s = newtags.setdefault(splitted_tag[0], set())
                    if not isinstance(s, set):
                        continue
                    s.add(splitted_tag[1])
            elif newtags.setdefault(splitted_tag[0], None) is not None:
                pass

    if (
        newtags.get("content_type") == {"PrivateKey"} and
        not newtags.get("key")
    ):
        raise ValueError("PrivateKey has no key=<foo> tag")
    return newtags, key_hashes
